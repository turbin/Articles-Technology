# The Introduction of the Principles For Oriented Object Design - 简述面向对象设计的基本准则

## Content:

   * **面向对象设计5原则:**
     * ***单一职责原则(Single Responsibility Principle - SRP)***
     * ***开放闭合原则(Open Close Principle, OCP)***
     * ***里氏替换原则(Liskov Substitution Priciple - LSP)***
     * ***接口隔离原则(Interface Segregation Principle,ISP)***
     * ***依赖倒置原则(Dependence Inversion Principle, DIP)***
  


---


## 1. The Introduction of the Principles For Oriented Object Design - 简述面向对象设计的基本准则

---

**在软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。 一套优秀的软件需要具备的标准是：高内聚，低耦合。**

如何实现上述标准呢？在设计一个面向对象的程序时我们应该遵循哪些准则进行实施呢？下面的内容就介绍面对对象的设计的5条原则，及其核心思想和解决方案。

* 面对对象设计5原则(S.O.L.I.D)：
    * a. 单一职责原则(Single Responsibility Principle - SRP)
    * b. 开放闭合原则(Open Close Principle - OCP)
    * c. 里氏替换原则(Liskov Substitution Priciple - LSP)
    * d. 接口隔离原则(Interface Segregation Principle - ISP)
    * e. 依赖倒置原则(Dependence Inversion Principle - DIP)

----

### A. 单一职责原则(Single Responsibility Principle - SRP)

  * 简介: 
    
    单一职责原则（SRP：Single responsibility principle）又称单一功能原则,它规定一个类应该只有一个发生变化的原因。
  
  * 核心思想：
  
    应该有且仅有一个原因引起类的变更；
  
  * 问题描述：
    
    之所以会出现单一职责原则就是因为在软件设计时会出现以下类似场景：
    
        T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。也就是说职责P1和P2被耦合在了一起。
  
  * 好处: 
  
    类的复杂程度降低、可读性提高、可维护性提高、降低了变更引发的风险；

  * 注意:

    单一职责原则提出了一个编写程序的标准，用“职责”或“变更原因”来衡量接口或类设计得是否优良，但是 ***“职责”*** 和 ***“变化原因”*** 都是不可度量的，因项目和环境而异。
  
  * 举个🌰：

    案例分析。

----

### B. 开放闭合原则(Open Close Principle - OCP)

  * 简介: 
    
    开放闭合原则，是所有面向对象原则的核心。软件设计本身所追求的目标就是封装变化、降低耦合，而开放封闭原则正是对这一目标的最直接体现。

  * 核心思想：
  
    尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化。软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。
    
    因此，开放封闭原则主要体现在两个方面：

    >1. 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。
    >2. 对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。

  * 问题描述: 
  
    > "All systems change during their life cycles. This must be borne in mind when developing systems expected to last longer than the first version。 - 所有系统在其生命周期中都会进行变化，只要系统要开发一个版本以上这一点就需时刻记住。" by Ivar Jacobson.

    那么我们到底如何才能构建一个稳定的设计来面对这些变化，以使软件生命周期持续的更长呢？当一个需求变化导致程序中多个依赖模块都发生了级联的改动，那么这个程序就展现出了我们所说的 "坏设计（bad design）" 的特质。应用程序也相应地变得脆弱、僵化、无法预期和无法重用。开放封闭原则（Open Closed Principle）即为解决这些问题而产生，它强调的是你设计的模块应该从不改变。***当需求变化时，你可以通过添加新的代码来扩展这个模块的行为，而不去更改那些已经存在的可以工作的代码***。
      
  * 解决方案:
  
      1. 需求识别：哪部分是需要封闭的，哪部分是需要扩展；
   
      2. 可以通过Template Method模式和Strategy模式进行重构，实现对修改封闭、对扩展开放的设计思路；

      3. 使用Liskov替换原则，合成/聚合复用原则为开放封闭原则来检验设计结果。
  
  * 举个🌰：

    案例分析。

---

### C. 里氏替换原则(Liskov Substitution Priciple - LSP)

  * 简介:
   
    里氏替换原则，OCP作为OO的高层原则，主张使用 **“抽象(Abstraction)”** 和 **“多态(Polymorphism)”** 将设计中的静态结构改为动态结构，维持设计的封闭性。 **“抽象”** 是语言提供的功能。**“多态”** 由继承语义实现。 
    
    ***这个准则是衡量基类设计的评价准则。***

  * 核心思想：
    
    里氏替换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为，即，当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系。
  
  * 问题描述:
    
    只要父类能出现的地方，子类就能出现。反之，父类则未必能胜任;
  
  * 好处：
    
    增强程序的健壮性，即使增加子类，原有的子类还可以继续运行;
  
  * 注意：
    
    如果子类不能完整地实现父类方法，或者父类的某些方法在子类中已经发生“变化”，则建议断开父子继承关系采用依赖、聚合、组合等关系代替继承。

  * 举个🌰：

    案例分析。

---   

### D. 依赖倒置原则(Dependence Inversion Principle - DIP)

  * 简介:
    
    依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。

    ***软件开发协作的原则：先协商，后各自实现，最后集成验证。***

  * 核心思想：

    * 高层模块不应该依赖底层模块，二者都该依赖其抽象；
    
    * 抽象类不应该依赖具体的类实例，具体的类实例应该依赖抽象类；

  * 问题描述：
  
    类A直接依赖类B，加入要将类A改为依赖类C，则必须通过修改类A 的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；所以如果修改类A，会给程序带来不必要的风险。
  
  * 解决方案: 
  
    将类A修改为依赖接口(Interface),类B和类C各自实现接口(Interface)。类A通过接口(Interface) 间接与类B或者类C发生联系，则会大大降低修改类A的几率。

  * 优势: 
    
    依赖倒置的好处在小型项目中很难体现出来，但是在大中型项目中可以减少需求变化引起的工作量，使并行开发更友好。

  * 举个🌰：

    案例分析。

---

### E. 接口隔离原则(Interface Segregation Principle - ISP)

  * 简介:
  
    客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 ***使用多个专门的接口比使用单一的总接口要好。*** 一个类对另外一个类的依赖性应当是建立在最小的接口上的。一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。

  * 核心思想：
 
    类间依赖关系应该建立在最小的接口上。
      
  * 问题描述：
  
    Class A通过接口(interface)依赖Class B，而Class C通过接口(Interface)依赖Class D,如果接口(Interface)对于Class A和 Class B来说不是最小接口，则Class B和Class D 必须去实现它们不需要的方法。

  * 解决方案:

    将类之间所依赖的接口职责进行单一化设计。
  
  * 举个🌰：

    案例分析。
  
## 2. Summary - 总结。

  **如何进行设计：从上自下设计，从下到上复核**

